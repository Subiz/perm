package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	typeName = flag.String("type", "", "permission type")
	fileName = flag.String("file", "", "pb.go file to parse")
	output   = flag.String("output", "", "output file name; default srcdir/<type>_string.go")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of stringer:\n")
	fmt.Fprintf(os.Stderr, "\tpermgen [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tpermgen [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://godoc.org/golang.org/x/tools/cmd/stringer\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("permgen: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	if len(*fileName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"perm_generator %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf(`
package perm

import "github.com/subiz/header/auth"

func contains(s string, ss []string) bool {
	for _, i := range ss {
		if i == s {
			return true
		}
	}
	return false
}

`)
	src, err := ioutil.ReadFile(*fileName)
	if err != nil {
		log.Fatalf("reading input: %s", err)
	}
	// Run generate for each type.
	g.generate(string(src), *typeName)

	// Format the output.
	src = g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_checker.go", *typeName)
		outputName = filepath.Join(".", strings.ToLower(baseName))
	}
	if err := ioutil.WriteFile(outputName, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// generate produces the String method for the named type.
func (g *Generator) generate(src, typeName string) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		log.Fatalf("parsing file: %s", err)
	}

	fieldNames := make([]string, 0, 100)
	// Set the state for this run of the walker.
	for _, itypeDecl := range file.Decls {
		typeDecl, ok := itypeDecl.(*ast.GenDecl)
		if !ok {
			continue
		}

		// filter out type
		structDecl, ok := typeDecl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}

		if structDecl.Name.Name != typeName {
			continue
		}

		fields := structDecl.Type.(*ast.StructType).Fields.List
		for _, field := range fields {

			nameExpr := field.Names[0]
			start := nameExpr.Pos() - 1
			end := nameExpr.End() - 1
			// grab it in source
			fieldName := src[start:end]

			if strings.Contains(fieldName, "XXX") {
				continue
			}
			fieldNames = append(fieldNames, fieldName)
		}
		break
	}

	if len(fieldNames) == 0 {
		log.Fatalf("no fields defined for type %s", typeName)
	}
	g.buildMultipleRuns(fieldNames, typeName)
	g.buildIntersectPermission(fieldNames, typeName)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// buildMultipleRuns generates the variables and String method for multiple runs of contiguous values.
// For this pattern, a single Printf format won't do.
func (g *Generator) buildMultipleRuns(fieldNames []string, typeName string) {

	g.Printf("\n")
	g.Printf(`
	var CREATEPERM = strPermToInt("c")
	var READPERM = strPermToInt("r")
	var UPDATEPERM = strPermToInt("u")
	var DELETEPERM = strPermToInt("d")

`)

	for _, name := range fieldNames {
		g.Printf(`func CheckCreate%s(cred *auth.Credential, accid string, agids ...string) error {
	callerperm := cred.GetPerm().Get%s()
	base := Base.Get%s()
	ismine := cred.GetAccountId() == accid && contains(cred.GetIssuer(), agids)
	isaccount := cred.GetAccountId() == accid
	return checkPerm(CREATEPERM, base, callerperm, ismine, isaccount)
}

func CheckRead%s(cred *auth.Credential, accid string, agids ...string) error {
	callerperm := cred.GetPerm().Get%s()
	base := Base.Get%s()
	ismine := cred.GetAccountId() == accid && contains(cred.GetIssuer(), agids)
	isaccount := cred.GetAccountId() == accid
	return checkPerm(READPERM, base, callerperm, ismine, isaccount)
}

func CheckUpdate%s(cred *auth.Credential, accid string, agids ...string) error {
	callerperm := cred.GetPerm().Get%s()
	base := Base.Get%s()
	ismine := cred.GetAccountId() == accid && contains(cred.GetIssuer(), agids)
	isaccount := cred.GetAccountId() == accid
	return checkPerm(UPDATEPERM, base, callerperm, ismine, isaccount)
}

func CheckDelete%s(cred *auth.Credential, accid string, agids ...string) error {
	callerperm := cred.GetPerm().Get%s()
	base := Base.Get%s()
	ismine := cred.GetAccountId() == accid && contains(cred.GetIssuer(), agids)
	isaccount := cred.GetAccountId() == accid
	return checkPerm(DELETEPERM, base, callerperm, ismine, isaccount)
}
`, name, name, name, name, name, name, name, name, name, name, name, name)
	}
}

func (g *Generator) buildIntersectPermission(fieldNames []string, typeName string) {
	fields := ""
	for _, name := range fieldNames {
		fields += fmt.Sprintf(`%s: a.Get%s() & b.Get%s(),`+"\n", name, name, name)
	}

	g.Printf(`
	func pInt32(i int32) *int32 {
		return &i
	}

	// IntersectPermission finds the intersection of permission a and permission b
	func IntersectPermission(a, b *auth.Permission) *auth.Permission {
		if a == nil {
			a = &auth.Permission{}
		}

		if b == nil {
			b = &auth.Permission{}
		}

		return &auth.Permission{
			%s
		}
	}`, fields)
}
